@using RexSimulator.Hardware
@using RexSimulator.Hardware.Wramp
@using System.Text
@using System.Text.RegularExpressions
@using System.Runtime.InteropServices

@inject IJSRuntime JSRuntime

<div class="mb-2">
    <h2>Controls</h2>

    <div class="btn-group me-2" role="group" aria-label="Code Controls">
        <button type="button" class="btn btn-warning" @onclick="OnCompileClicked">Compile</button>
        <button type="button" class="btn btn-info" @onclick="saveCode">Save</button>
    </div>

    <div class="btn-group" role="group" aria-label="WRAMP Controls">
        <button type="button" class="btn btn-warning" @onclick="Undo">Undo</button>
        <button type="button" class="btn btn-success" @onclick="Run" hidden="@running">Run</button>
        <button type="button" class="btn btn-success" @onclick="Pause" hidden="@(!running)">Pause</button>
        <button type="button" class="btn btn-info" @onclick="Step">Step</button>
    </div>

</div>

<div class="overflow-scroll">
    @if (Tabs.LEDs || Tabs.Switches || Tabs.Buttons || Tabs.SSDs)
    {
        <div class="accordion my-2">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                        Physical Components
                    </button>
                </h2>
                <div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        @if (Tabs.LEDs)
                        {
                            <div class="row justify-content-center">
                                @for (int i = 15; i != -1; i--)
                                {
                                    int pos = i;
                                    string id = "led" + i;
                                    <div class="led col-auto" id="@id"></div>
                                }
                            </div>
                        }

                        @if (Tabs.Switches)
                        {
                            <div id="switches">
                                @for (int i = 0; i < 16; i++)
                                {
                                    int pos = i;
                                    int value = (int)Math.Pow(2, pos);
                                    string ID = "switch" + i;
                                    <div class="form-check form-switch">
                                        <input class="form-check-input" type="checkbox" role="switch" id="@ID" @onclick="() => toggleSwitch(pos)">
                                        <label class="form-check-label" for="@ID">Switch @pos</label>
                                    </div>
                                }
                            </div>
                        }

                        @if (Tabs.Buttons)
                        {
                            <div class="d-flex justify-content-center">
                                @for (int i = 0; i < 3; i++)
                                {
                                    int pos = i;
                                    <button type="button" class="btn btn-primary me-2" @onmousedown="() => pressButton(pos)" @onmouseup="releaseButton">Button</button>
                                }
                            </div>
                        }

                        @if (Tabs.SSDs)
                        {
                            <div class="row justify-content-center">
                                <div id="sevenSegOne" class="display-container display-size-12 col-auto">
                                    <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                    <div class="segment-h"></div>
                                </div>
                                <div id="sevenSegTwo" class="display-container display-size-12 col-auto">
                                    <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                    <div class="segment-h"></div>
                                </div>
                                <div id="sevenSegThree" class="display-container display-size-12 col-auto">
                                    <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                    <div class="segment-h"></div>
                                </div>
                                <div id="sevenSegFour" class="display-container display-size-12 col-auto">
                                    <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                    <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                    <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                    <div class="segment-h"></div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }

    <ul class="nav nav-tabs" role="tablist">
        @if (Tabs.Instructions && Instructions != null)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="instructions-tab" data-bs-toggle="tab" data-bs-target="#instructions-tab-pane" type="button" role="tab" aria-controls="instructions-tab-pane" aria-selected="true">Instructions</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-tab-pane" type="button" role="tab" aria-controls="code-tab-pane" aria-selected="false">Code</button>
            </li>
        }
        else
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-tab-pane" type="button" role="tab" aria-controls="code-tab-pane" aria-selected="true">Code</button>
            </li>
        }
        @if (Tabs.GPRegisters)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="gp-tab" data-bs-toggle="tab" data-bs-target="#gp-tab-pane" type="button" role="tab" aria-controls="gp-tab-pane" aria-selected="false">GP Registers</button>
            </li>
        }
        @if (Tabs.SPRegisters)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="sp-tab" data-bs-toggle="tab" data-bs-target="#sp-tab-pane" type="button" role="tab"
                aria-controls="sp-tab-pane" aria-selected="false">SP Registers</button>
            </li>
        }
        @if (Tabs.RAM)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="ram-tab" data-bs-toggle="tab" data-bs-target="#ram-tab-pane" type="button" role="tab" aria-controls="ram-tab-pane" aria-selected="false">RAM</button>
            </li>
        }
        @if (Tabs.ParallelRegisters)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="parallel-tab" data-bs-toggle="tab" data-bs-target="#parallel-tab-pane" type="button" role="tab" aria-controls="parallel-tab-pane" aria-selected="false">Parallel Registers</button>
            </li>
        }
        @if (Tabs.SerialPort)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="serial-tab" data-bs-toggle="tab" data-bs-target="#serial-tab-pane" type="button" role="tab" aria-controls="serial-tab-pane" aria-selected="false">Serial Port</button>
            </li>
        }
        @if (Tabs.Library && Library != null)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="library-tab" data-bs-toggle="tab" data-bs-target="#library-tab-pane" type="button" role="tab" aria-controls="library-tab-pane" aria-selected="false">@Library[0]</button>
            </li>
        }
        <li class="nav-item ms-auto" role="presentation" @onclick="quack">
            <button class="nav-link duck" id="duck-tab"><img src="img/reginald.png" class="duckImg" alt="duck!"></button>
        </li>
    </ul>

    <div class="tab-content">
        @if (Tabs.Instructions && Instructions != null)
        {
            <div class="tab-pane fade show active" id="instructions-tab-pane" role="tabpanel" aria-labelledby="instructions-tab" tabindex="0">
                <pre>@((MarkupString)Instructions)</pre>
            </div>
            <div class="tab-pane fade" id="code-tab-pane" role="tabpanel" aria-labelledby="code-tab" tabindex="0">
                <p id="wsimCode"></p>
            </div>
        }
        else
        {
            <div class="tab-pane fade show active" id="code-tab-pane" role="tabpanel" aria-labelledby="code-tab" tabindex="0">
                <p id="wsimCode"></p>
            </div>
        }
        @if (Tabs.GPRegisters)
        {
            <div class="tab-pane fade" id="gp-tab-pane" role="tabpanel" aria-labelledby="gp-tab" tabindex="0">
                <Registers CPU="@board.CPU" registerType="@RegisterType.GP"/>
            </div>
        }
        @if (Tabs.SPRegisters)
        {
            <div class="tab-pane fade" id="sp-tab-pane" role="tabpanel" aria-labelledby="sp-tab" tabindex="0">
                <Registers CPU="@board.CPU" registerType="@RegisterType.SP"/>
            </div>
        }
        @if (Tabs.RAM)
        {
            <div class="tab-pane fade mDevice" id="ram-tab-pane" role="tabpanel" aria-labelledby="ram-tab" tabindex="0">
                <Memory CPU="@board.CPU" mDevice="@board.RAM" wordsLoaded="@finalAddress" labels="@labels"/>
            </div>
        }
        @if (Tabs.ParallelRegisters)
        {
            <div class="tab-pane fade" id="parallel-tab-pane" role="tabpanel" aria-labelledby="parallel-tab" tabindex="0">
                <PeripheralMemory parallelMemory="@board.Parallel"/>
            </div>
        }
        @if (Tabs.SerialPort)
        {
            <div class="tab-pane fade" id="serial-tab-pane" role="tabpanel" aria-labelledby="serial-tab" tabindex="0">
                <SerialPort serial="@board.Serial1"/>
            </div>
        }
        @if (Tabs.Library && Library != null)
        {
            <div class="tab-pane fade" id="library-tab-pane" role="tabpanel" aria-labelledby="library-tab" tabindex="0">
                <pre>@((MarkupString)Library[1])</pre>
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public EventCallback CompileRequested { get; set; }

    [Parameter]
    required public List<KeyValuePair<int, int>> Registers { get; set; }

    [Parameter]
    required public Tabs Tabs { get; set; }

    [Parameter]
    public string? Instructions { get; set; }

    [Parameter]
    public string[]? Library { get; set; }

    public enum ExceptionSource { GPF = 0x1000, SYSCALL = 0x2000, BREAK = 0x4000, ARITH = 0x8000 }

    public List<BoardState> memoryStates = new List<BoardState>();
    public List<BoardState> gpRegisterStates = new List<BoardState>();
    public List<BoardState> spRegisterStates = new List<BoardState>();
    public List<BoardState> interruptStates = new List<BoardState>();
    public List<BoardState> pRegisterStates = new List<BoardState>();
    public List<uint> pcStates = new List<uint>();

    required public string[] blockIDs;
    required public List<string> labels;

    //WSIM Operation
    RexBoard board = new RexBoard();
    uint finalAddress = 50;

    bool instructionsLoaded = false;
    bool running = false;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            //Load SSDs on page load
            updateSSDs();
            StateHasChanged();
        }
    }

    async Task OnCompileClicked()
    {
        await CompileRequested.InvokeAsync();
    }

    //Take a .s file onclickfrom the user and compile it to an SREC for use in the wsim
    public async Task Compile((string code, string[] IDs, List<string> labels) args)
    {
        //Get block IDs, labels, and plain text code from args
        blockIDs = args.IDs;
        labels = args.labels;

        //Reset board
        board.Reset();
        running = false;

        //Remove any stored states
        memoryStates.Clear();
        gpRegisterStates.Clear();
        spRegisterStates.Clear();
        pcStates.Clear();
        interruptStates.Clear();
        pRegisterStates.Clear();

        //Update UI
        updateSSDs();
        updateLEDs();
        updateSwitches();
        StateHasChanged();

        byte[] codeBytes;

        if (Library != null)
        {
            string htmlTags = @"<table>|</table>|<tr>|</tr>|<td>|</td>\n";
            string libraryCode = Regex.Replace(Library[1], htmlTags, "");
            string combinedCode = args.code + "\n" + libraryCode;
            codeBytes = Encoding.UTF8.GetBytes(combinedCode);
        }
        else
        {
            codeBytes = Encoding.UTF8.GetBytes(args.code);
        }

        //Call assembleAndLink from app.js to compile the .s file and retrieve the resulting .srec file as bytes
        try
        {
            byte[] srecBytes = await JSRuntime.InvokeAsync<byte[]>("assembleAndLink", "input.s", codeBytes);
            //Open a new memory stream, and pass to wsim for execution
            MemoryStream ms = new MemoryStream(srecBytes);
            finalAddress = await board.LoadSrecAsync(ms);
            if (finalAddress != 0)
            {
                instructionsLoaded = true;
                await JSRuntime.InvokeVoidAsync("highlightBlock", blockIDs[0]);
            }
            StateHasChanged();
        }
        catch {
            labels.Clear();
        }
    }

    //Executes a single instruction
    async Task Step()
    {
        if (instructionsLoaded == true)
        {
            await WSIMWorker(true);
        }
    }

    //Continuously executes instructions
    async Task Run()
    {
        if (instructionsLoaded == true)
        {
            await WSIMWorker(false);
        }
    }

    //Pause execution of instructions
    void Pause()
    {
        running = false;
    }

    async Task WSIMWorker(bool stepping)
    {
        running = true;
        while (running)
        {
            //Only do one cycle if the step button was clicked
            running ^= stepping;
            //Catch any system exceptions
            switch (board.CPU.InterruptStatus & (uint)0xF000)
            {
                case (uint)ExceptionSource.GPF:
                    running = false;
                    if (board.CPU.PC > finalAddress)
                    {
                        await JSRuntime.InvokeVoidAsync("alert", "GPF thrown! Have you tried adding an $ra?");
                        break;
                    }
                    await JSRuntime.InvokeVoidAsync("alert", "GPF thrown!");
                    break;
                case (uint)ExceptionSource.SYSCALL:
                    running = false;
                    await JSRuntime.InvokeVoidAsync("alert", "Syscall exception thrown!");
                    break;
                case (uint)ExceptionSource.BREAK:
                    running = false;
                    await JSRuntime.InvokeVoidAsync("alert", "Breakpoint exception thrown!");
                    break;
                case (uint)ExceptionSource.ARITH:
                    running = false;
                    await JSRuntime.InvokeVoidAsync("alert", "Arithmetic exception thrown!");
                    break;
                default:
                    //If the user used jr $ra correctly
                    if (board.CPU.PC == 0xFFFFF)
                    {
                        running = false;
                        Verify();
                        break;
                    }

                    //Store board state
                    StoreBoardState();

                    //Execute next instruction
                    while(!board.Tick());

                    //Highlight next block to be executed (try catch used to account for library code which is un-highlightable)
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("highlightBlock", blockIDs[board.CPU.PC]);
                    }
                    catch
                    {
                        await JSRuntime.InvokeVoidAsync("highlightBlock", null);
                    }

                    //Update SSDs & LEDs
                    updateSSDs();
                    updateLEDs();
                    updateSwitches();

                    //Update UI, and add a delay between instructions
                    await InvokeAsync(StateHasChanged);
                    await Task.Delay(100);
                    break;
            }
        }
    }

    //Used to check the output of the user's program
    void Verify()
    {
        bool correct = true;
        foreach (KeyValuePair<int, int> answer in Registers)
        {
            uint userRegister = board.CPU.mGpRegisters[(RegisterFile.GpRegister)answer.Key];
            if (userRegister != answer.Value)
            {
                correct = false;
            }
        }
        if (correct == true)
        {
            JSRuntime.InvokeVoidAsync("alert", "You did it!");
        }
    }

    void StoreBoardState()
    {
        //Store board state, either creating a new entry if it is unique, or incrementing the repeat value for the previous state
        if (memoryStates.Count == 0 || !memoryStates[^1].Keys.SequenceEqual(board.RAM.mMemory))
        {
            memoryStates.Add(new ((uint[])board.RAM.mMemory.Clone()));
        }
        else
        {
            memoryStates[^1].Repeats++;
        }
        if (gpRegisterStates.Count == 0 || !gpRegisterStates[^1].Keys.SequenceEqual(board.CPU.mGpRegisters.mRegisters))
        {
            gpRegisterStates.Add(new ((uint[])board.CPU.mGpRegisters.mRegisters.Clone()));
        }
        else
        {
            gpRegisterStates[^1].Repeats++;
        }
        if (spRegisterStates.Count == 0 || !spRegisterStates[^1].Keys.SequenceEqual(board.CPU.mSpRegisters.mRegisters))
        {
            spRegisterStates.Add(new ((uint[])board.CPU.mSpRegisters.mRegisters.Clone()));
        }
        else
        {
            spRegisterStates[^1].Repeats++;
        }
        if (interruptStates.Count == 0 || board.CPU.InterruptStatus != interruptStates[^1].Key)
        {
            interruptStates.Add(new BoardState(board.CPU.InterruptStatus));
        }
        else
        {
            interruptStates[^1].Repeats++;
        }
        if (pRegisterStates.Count == 0 || !pRegisterStates[^1].Keys.SequenceEqual(board.Parallel.mMemory))
        {
            pRegisterStates.Add(new BoardState((uint[])board.Parallel.mMemory.Clone()));
        }
        else
        {
            pRegisterStates[^1].Repeats++;
        }
        pcStates.Add(board.CPU.PC);
    }

    //Go back one board state
    void Undo()
    {
        //If there is a state to revert to
        if (pcStates.Count != 0)
        {
            //Restore previous states
            board.RAM.mMemory = memoryStates[^1].Keys;
            board.CPU.mGpRegisters.mRegisters = gpRegisterStates[^1].Keys;
            board.CPU.mSpRegisters.mRegisters = spRegisterStates[^1].Keys;
            board.CPU.InterruptStatus = (uint)interruptStates[^1].Key;
            board.CPU.mPC = pcStates[^1];
            board.Parallel.mMemory = pRegisterStates[^1].Keys;

            //Highlight previous block (try catch used to account for library code which is un-highlightable)
            try
            {
                JSRuntime.InvokeVoidAsync("highlightBlock", blockIDs[board.CPU.PC]);
            }
            catch {}

            //Remove restored states from list or decrement number of repeats
            if (--memoryStates[^1].Repeats < 0)
            {
                memoryStates.RemoveAt(memoryStates.Count - 1);
            }
            if (--gpRegisterStates[^1].Repeats < 0)
            {
                gpRegisterStates.RemoveAt(gpRegisterStates.Count - 1);
            }
            if (--spRegisterStates[^1].Repeats < 0)
            {
                spRegisterStates.RemoveAt(spRegisterStates.Count - 1);
            }
            if (--interruptStates[^1].Repeats < 0)
            {
                interruptStates.RemoveAt(interruptStates.Count - 1);
            }
            if (--pRegisterStates[^1].Repeats < 0)
            {
                pRegisterStates.RemoveAt(pRegisterStates.Count - 1);
            }
            pcStates.RemoveAt(pcStates.Count - 1);

            //Update UI
            updateLEDs();
            updateSSDs();
            updateSwitches();
            StateHasChanged();
        }
    }

    void toggleSwitch(int pos)
    {
        board.Parallel.Switches ^= (1u << pos);
    }

    void pressButton(int pos)
    {
        board.Parallel.Buttons = (uint)1 << pos;
    }

    void releaseButton()
    {
        board.Parallel.Buttons = 0;
    }

    void updateSSDs()
    {
        uint[] SSD_DECODE = { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x7, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };
        uint[] values = {board.Parallel.LeftLeftSSD, board.Parallel.LeftRightSSD, board.Parallel.LeftSSD, board.Parallel.RightSSD};
        string[] IDs = {"sevenSegOne", "sevenSegTwo", "sevenSegThree", "sevenSegFour"};
        //If Hex-decode is enabled
        if ((board.Parallel.Control & 1) == 1)
        {
            for (int i = 0; i < values.Length; i++)
            {
                uint value = values[i] & 0xF;
                uint segments = SSD_DECODE[value];
                for (int i2 = 0; i2 < 8; i2++)
                {
                    uint bit = segments & 1;
                    JSRuntime.InvokeVoidAsync("changeSegment", IDs[i], i2, bit);
                    segments >>= 1;
                }
            }
        }
        else
        {
            for (int i = 0; i < values.Length; i++)
            {
                for (int i2 = 0; i2 < 8; i2++)
                {
                    uint bit = values[i] & 1;;
                    JSRuntime.InvokeVoidAsync("changeSegment", IDs[i], i2, bit);
                    values[i] >>= 1;
                }
            }
        }
    }

    void updateLEDs()
    {
        uint LEDValues = board.Parallel.Leds;
        for (int i = 0; i < 16; i++)
        {
            string ID = "led" + i;
            uint value = LEDValues & 1;
            JSRuntime.InvokeVoidAsync("changeLED", ID, value);
            LEDValues >>= 1;
        }
    }

    void updateSwitches()
    {
        uint switchValues = board.Parallel.Switches;
        for (int i = 0; i < 16; i++)
        {
            string ID = "switch" + i;
            uint value = switchValues & 1;
            JSRuntime.InvokeVoidAsync("changeSwitch", ID, value);
            switchValues >>= 1;
        }
    }

    void quack()
    {
        JSRuntime.InvokeVoidAsync("quacker");
    }

    void saveCode()
    {
        JSRuntime.InvokeVoidAsync("saveCode");
    }
}