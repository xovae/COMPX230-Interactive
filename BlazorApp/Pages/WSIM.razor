@using RexSimulator.Hardware
@using RexSimulator.Hardware.Rex
@using RexSimulator.Hardware.Wramp
@using System.ComponentModel
@using System.Security.Permissions
@using System.Text
@using System.Text.Json
@using System.Runtime.Intrinsics.X86
@using System.Diagnostics.Contracts
@using System.ComponentModel.Design
@inject IJSRuntime JSRuntime

<div>
    <h2>Controls</h2>
    <button type="button" class="btn btn-warning wrampButton" @onclick="OnCompileClicked">Compile</button>

    <div class="btn-group" role="group" aria-label="WRAMP controls">
        <button type="button" class="btn btn-info" @onclick="Step">Step</button>
        <button type="button" class="btn btn-success" @onclick="Run" hidden="@running">Run</button>
        <button type="button" class="btn btn-success" @onclick="Pause" hidden="@(!running)">Pause</button>
        <button type="button" class="btn btn-warning" @onclick="Undo">Undo</button>
    </div>

    @if (Tabs.PhysicalComponents)
    {
        <div id="accordionWRAMP" class="accordion">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                        Physical Components
                    </button>
                </h2>
                <div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                        <div id="switches">
                            @for (int i = 0; i < 16; i++) {
                                int pos = i;
                                int value = (int)Math.Pow(2, pos);
                                <div class="form-check form-switch">
                                    <input class="form-check-input" type="checkbox" role="switch" id="@pos" @onclick="() => toggleSwitch(pos)">
                                    <label class="form-check-label" for="@pos">Switch @pos</label>
                                </div>
                            }
                        </div>

                        <div class="d-flex justify-content-center">
                            @for (int i = 0; i < 3; i++) {
                                int pos = i;
                                <button type="button" class="btn btn-primary wrampButton" @onmousedown="() => pressButton(pos)" @onmouseup="releaseButton">Button</button>
                            }
                        </div>

                        <div class="row justify-content-center">
                            <div id="sevenSegOne" class="display-container display-size-12 col-auto">
                                <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                <div class="segment-h"></div>
                            </div>
                            <div id="sevenSegTwo" class="display-container display-size-12 col-auto">
                                <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                <div class="segment-h"></div>
                            </div>
                            <div id="sevenSegThree" class="display-container display-size-12 col-auto">
                                <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                <div class="segment-h"></div>
                            </div>
                            <div id="sevenSegFour" class="display-container display-size-12 col-auto">
                                <div class="segment-x segment-a"><span class="segment-border"></span></div>
                                <div class="segment-y segment-b"><span class="segment-border"></span></div>
                                <div class="segment-y segment-c"><span class="segment-border"></span></div>
                                <div class="segment-x segment-d"><span class="segment-border"></span></div>
                                <div class="segment-y segment-e"><span class="segment-border"></span></div>
                                <div class="segment-y segment-f"><span class="segment-border"></span></div>
                                <div class="segment-x segment-g"><span class="segment-border"></span></div>
                                <div class="segment-h"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

<ul class="nav nav-tabs" id="wsimTabs" role="tablist">
    @if (Tabs.Instructions && Instructions != null)
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="instructions-tab" data-bs-toggle="tab" data-bs-target="#instructions-tab-pane" type="button" role="tab" aria-controls="instructions-tab-pane" aria-selected="true">Instructions</button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-tab-pane" type="button" role="tab" aria-controls="code-tab-pane" aria-selected="false">Code</button>
        </li>
    }
    else
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-tab-pane" type="button" role="tab" aria-controls="code-tab-pane" aria-selected="true">Code</button>
        </li>
    }
    @if (Tabs.GPRegisters)
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="gp-tab" data-bs-toggle="tab" data-bs-target="#gp-tab-pane" type="button" role="tab" aria-controls="gp-tab-pane" aria-selected="false">GP Registers</button>
        </li>
    }
    @if (Tabs.RAM)
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="ram-tab" data-bs-toggle="tab" data-bs-target="#ram-tab-pane" type="button" role="tab" aria-controls="ram-tab-pane" aria-selected="false">RAM</button>
        </li>
    }
    @if (Tabs.ParallelRegisters)
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="parallel-tab" data-bs-toggle="tab" data-bs-target="#parallel-tab-pane" type="button" role="tab" aria-controls="parallel-tab-pane" aria-selected="false">Parallel Registers</button>
        </li>
    }
    @if (Tabs.SerialPort)
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="serial-tab" data-bs-toggle="tab" data-bs-target="#serial-tab-pane" type="button" role="tab" aria-controls="serial-tab-pane" aria-selected="false">Serial Port</button>
        </li>
    }
    @if (Tabs.Library && Library != null)
    {
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="library-tab" data-bs-toggle="tab" data-bs-target="#library-tab-pane" type="button" role="tab" aria-controls="library-tab-pane" aria-selected="false">@Library[0]</button>
        </li>
    }
    <li class="nav-item ms-auto" role="presentation" @onclick="quack">
        <button class="nav-link duck" id="duck-tab"><img src="img/reginald.png" class="duckImg" alt="duck!"></button>
    </li>
</ul>

<div class="tab-content">
    @if (Tabs.Instructions && Instructions != null)
    {
        <div class="tab-pane fade show active" id="instructions-tab-pane" role="tabpanel" aria-labelledby="instructions-tab" tabindex="0">
            @((MarkupString)Instructions.Replace("\n", "<br />"));
        </div>
        <div class="tab-pane fade" id="code-tab-pane" role="tabpanel" aria-labelledby="code-tab" tabindex="0">
            <p id="wsimCode"></p>
        </div>
    }
    else
    {
        <div class="tab-pane fade show active" id="code-tab-pane" role="tabpanel" aria-labelledby="code-tab" tabindex="0">
            <p id="wsimCode"></p>
        </div>
    }
    @if (Tabs.GPRegisters)
    {
        <div class="tab-pane fade" id="gp-tab-pane" role="tabpanel" aria-labelledby="gp-tab" tabindex="0">
            <GPRegisters CPU="@board.CPU" />
        </div>
    }
    @if (Tabs.RAM)
    {
        <div class="tab-pane fade mDevice" id="ram-tab-pane" role="tabpanel" aria-labelledby="ram-tab" tabindex="0">
            <Memory CPU="@board.CPU" mDevice="@board.RAM" wordsLoaded="@finalAddress" labels="@labels" />
        </div>
    }
    @if (Tabs.ParallelRegisters)
    {
        <div class="tab-pane fade" id="parallel-tab-pane" role="tabpanel" aria-labelledby="parallel-tab" tabindex="0">
            <ParallelRegisters parallelMemory="@board.Parallel" />
        </div>
    }
    @if (Tabs.SerialPort)
    {
        <div class="tab-pane fade" id="serial-tab-pane" role="tabpanel" aria-labelledby="serial-tab" tabindex="0">
            <SerialPort serial="@board.Serial1" />
        </div>
    }
    @if (Tabs.Library && Library != null)
    {
        <div class="tab-pane fade" id="library-tab-pane" role="tabpanel" aria-labelledby="library-tab" tabindex="0">
            <p>@Library[1]</p>
        </div>
    }
</div>


@code {
    [Parameter]
    public EventCallback CompileRequested { get; set; }

    [Parameter]
    required public List<KeyValuePair<int, int>> Registers { get; set; }

    [Parameter]
    required public Tabs Tabs { get; set; }

    [Parameter]
    public string? Instructions { get; set; }

    [Parameter]
    public string[]? Library { get; set; }

    private enum ExceptionSource { GPF = 0x1000, SYSCALL = 0x2000, BREAK = 0x4000, ARITH = 0x8000 }

    required public string[] blockIDs;
    required public List<string> labels;

    //WSIM Operation
    RexBoard board = new RexBoard();
    uint finalAddress = 50;

    bool instructionsLoaded = false;
    bool running = false;
    bool hexDecode = true;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            //Load SSDs on page load
            updateDisplays();
            StateHasChanged();
        }
    }

    async Task OnCompileClicked()
    {
        await CompileRequested.InvokeAsync();
    }

    //Take a .s file onclickfrom the user and compile it to an SREC for use in the wsim
    public async Task Compile((string code, string[] IDs, List<string> labels) args)
    {
        //Get block IDs, labels, and plain text code from args
        blockIDs = args.IDs;
        labels = args.labels;

        //Reset board
        board.Reset();
        running = false;
        StateHasChanged();

        byte[] codeBytes = Encoding.UTF8.GetBytes(args.code);

        //Call assembleAndLink from app.js to compile the .s file and retrieve the resulting .srec file as bytes
        try
        {
            byte[] srecBytes = await JSRuntime.InvokeAsync<byte[]>("assembleAndLink", "input.s", codeBytes);
            //Open a new memory stream, and pass to wsim for execution
            MemoryStream ms = new MemoryStream(srecBytes);
            finalAddress = await board.LoadSrecAsync(ms);
            if (finalAddress != 0)
            {
                instructionsLoaded = true;
                await JSRuntime.InvokeAsync<byte[]>("highlightBlock", blockIDs[0]);
            }
            StateHasChanged();
        }
        catch {
            labels.Clear();
        }
    }

    //Executes a single instruction
    async Task Step()
    {
        if (instructionsLoaded == true)
        {
            await WSIMWorker(true);
        }
    }

    //Continuously executes instructions
    async Task Run()
    {
        if (instructionsLoaded == true)
        {
            await WSIMWorker(false);
        }
    }

    //Pause execution of instructions
    void Pause()
    {
        running = false;
    }

    async Task WSIMWorker(bool stepping)
    {
        running = true;
        while (running)
        {
            //Only do one cycle if the step button was clicked
            running ^= stepping;
            //Catch any system exceptions
            switch (board.CPU.InterruptStatus & (uint)0xF000)
            {
                case (uint)ExceptionSource.GPF:
                    running = false;
                    if (board.CPU.PC > finalAddress)
                    {
                        await JSRuntime.InvokeVoidAsync("alert", "GPF thrown! Have you tried adding an $ra?");
                        break;
                    }
                    await JSRuntime.InvokeVoidAsync("alert", "GPF thrown!");
                    break;
                case (uint)ExceptionSource.SYSCALL:
                    running = false;
                    await JSRuntime.InvokeVoidAsync("alert", "Syscall exception thrown!");
                    break;
                case (uint)ExceptionSource.BREAK:
                    running = false;
                    await JSRuntime.InvokeVoidAsync("alert", "Breakpoint exception thrown!");
                    break;
                case (uint)ExceptionSource.ARITH:
                    running = false;
                    await JSRuntime.InvokeVoidAsync("alert", "Arithmetic exception thrown!");
                    break;
                default:
                    //If the user used jr $ra
                    if (board.CPU.PC == 0xFFFFF)
                    {
                        running = false;
                        Verify();
                        break;
                    }
                    while(!board.Tick());
                    //Highlight next block to be executed
                    if (board.CPU.PC < finalAddress)
                    {
                        await JSRuntime.InvokeAsync<byte[]>("highlightBlock", blockIDs[board.CPU.PC]);
                    }
                    //Update SSDs
                    updateDisplays();
                    await InvokeAsync(StateHasChanged);
                    await Task.Delay(100);
                    break;
            }
        }
    }

    //Used to check the output of the user's program
    void Verify()
    {
        bool correct = true;
        foreach (KeyValuePair<int, int> answer in Registers)
        {
            uint userRegister = board.CPU.mGpRegisters[(RegisterFile.GpRegister)answer.Key];
            if (userRegister != answer.Value)
            {
                correct = false;
            }
        }
        if (correct == true)
        {
            Console.WriteLine("You did it!");
        }
    }

    //Go back one board state
    void Undo()
    {
    }

    void toggleSwitch(int pos)
    {
        board.Parallel.Switches ^= (1u << pos);
    }

    void pressButton(int pos)
    {
        board.Parallel.Buttons = (uint)1 << pos;
    }

    void releaseButton()
    {
        board.Parallel.Buttons = 0;
    }

    void updateDisplays()
    {
        uint[] SSD_DECODE = { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x7, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };
        uint[] values = {board.Parallel.LeftLeftSSD, board.Parallel.LeftRightSSD, board.Parallel.LeftSSD, board.Parallel.RightSSD};
        string[] IDs = {"sevenSegOne", "sevenSegTwo", "sevenSegThree", "sevenSegFour"};
        //If Hex-decode is enabled
        if ((board.Parallel.Control & 1) == 1)
        {
            for (int i = 0; i < values.Length; i++)
            {
                uint value = values[i] & 0xF;
                uint segments = SSD_DECODE[value];
                for (int i2 = 0; i2 < 8; i2++)
                {
                    uint bit = segments & 1;
                    JSRuntime.InvokeVoidAsync("changeSegment", IDs[i], i2, bit);
                    segments >>= 1;
                }
            }
        }
        else
        {
            for (int i = 0; i < values.Length; i++)
            {
                for (int i2 = 0; i2 < 8; i2++)
                {
                    uint bit = values[i] & 1;;
                    JSRuntime.InvokeVoidAsync("changeSegment", IDs[i], i2, bit);
                    values[i] >>= 1;
                }
            }
        }
    }

    void quack()
    {
        JSRuntime.InvokeVoidAsync("quacker");
    }
}