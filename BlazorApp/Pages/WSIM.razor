@using RexSimulator.Hardware
@using System.Text
@using System.Text.RegularExpressions
@using RexSimulator.Hardware.Rex

@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="mb-2">
    <h2>Controls</h2>

    <div class="btn-group me-2" role="group" aria-label="Code Controls">
        <button type="button" id="compileButton" class="btn btn-warning" @onclick="OnCompileClicked" data-bs-toggle="popover" data-bs-placement="bottom" data-bs-custom-class="compilePopover">Compile</button>
        <button type="button" class="btn btn-info" @onclick="saveCode">Save</button>
    </div>

    <div class="btn-group" role="group" aria-label="WRAMP Controls">
        <button type="button" class="btn btn-warning" @onclick="Undo">Undo</button>
        <button type="button" class="btn btn-success" @onclick="Run" hidden="@running">Run</button>
        <button type="button" class="btn btn-success" @onclick="Pause" hidden="@(!running)">Pause</button>
        <button type="button" class="btn btn-info" @onclick="Step">Step</button>
    </div>

</div>

<div class="overflow-scroll">
    @if (UIComponents.LEDs || UIComponents.Switches || UIComponents.Buttons || UIComponents.SSDs)
    {
        <div class="accordion my-2">
            <div class="accordion-item">
                <h2 class="accordion-header">
                    <button class="accordion-button collapsed text-end" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="false" aria-controls="collapseOne">
                        Physical Components
                    </button>
                </h2>
                <div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#accordionExample">
                    <div class="accordion-body">

                        <a class="float-end" id="tooltip" data-bs-toggle="tooltip" data-bs-html="true" data-bs-title="Physical Components can be accessed using these labels:<br>Switches: par_switch<br>LEDs: par_led<br>Buttons: par_btn<br>SSDs: par_ulssd, par_urssd, par_llssd, par_lrssd">
                            <i class="bi bi-question-circle text-body"></i>
                        </a>

                        @if (UIComponents.LEDs || UIComponents.Switches)
                        {
                            <div class="row justify-content-center">
                                @for (int i = 15; i != -1; i--)
                                {
                                    int pos = i;
                                    int value = (int)Math.Pow(2, pos);
                                    string ledID = "led" + i;
                                    string switchID = "switch" + i;

                                    <div class="col-auto p-0 mb-3">
                                        @if (UIComponents.LEDs)
                                        {
                                            <div class="led mb-2" id="@ledID"></div>
                                        }
                                        @if (UIComponents.Switches)
                                        {
                                            <div class="form-check form-switch wsimSwitch">
                                                <input class="form-check-input" type="checkbox" role="switch" id="@switchID" @onclick="() => toggleSwitch(pos)">
                                            </div>
                                        }
                                    </div>
                                }
                            </div>
                        }

                        @if (UIComponents.Buttons)
                        {
                            <div class="d-flex justify-content-center mt-2">
                                @for (int i = 0; i < 3; i++)
                                {
                                    int pos = i;
                                    <button type="button" class="btn btn-primary me-2" @onmousedown="() => pressButton(pos)" @onmouseup="releaseButton">Button</button>
                                }
                            </div>
                        }

                        @if (UIComponents.SSDs)
                        {
                            <div class="row justify-content-center">
                                <SSD ID="sevenSegOne"/>
                                <SSD ID="sevenSegTwo"/>
                                <SSD ID="sevenSegThree"/>
                                <SSD ID="sevenSegFour"/>
                            </div>
                        }
                    </div>
                </div>
            </div>
        </div>
    }

    <ul class="nav nav-tabs" role="tablist">
        @if (UIComponents.WSIMInstructions && WSIMInstructions != null)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="instructions-tab" data-bs-toggle="tab" data-bs-target="#instructions-tab-pane" type="button" role="tab" aria-controls="instructions-tab-pane" aria-selected="true">Instructions</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-tab-pane" type="button" role="tab" aria-controls="code-tab-pane" aria-selected="false">Code</button>
            </li>
        }
        else
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="code-tab" data-bs-toggle="tab" data-bs-target="#code-tab-pane" type="button" role="tab" aria-controls="code-tab-pane" aria-selected="true">Code</button>
            </li>
        }
        @if (UIComponents.GPRegisters)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="gp-tab" data-bs-toggle="tab" data-bs-target="#gp-tab-pane" type="button" role="tab" aria-controls="gp-tab-pane" aria-selected="false">GP Registers</button>
            </li>
        }
        @if (UIComponents.SPRegisters)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="sp-tab" data-bs-toggle="tab" data-bs-target="#sp-tab-pane" type="button" role="tab"
                aria-controls="sp-tab-pane" aria-selected="false">SP Registers</button>
            </li>
        }
        @if (UIComponents.RAM)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="ram-tab" data-bs-toggle="tab" data-bs-target="#ram-tab-pane" type="button" role="tab" aria-controls="ram-tab-pane" aria-selected="false">RAM</button>
            </li>
        }
        @if (UIComponents.ParallelRegisters)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="parallel-tab" data-bs-toggle="tab" data-bs-target="#parallel-tab-pane" type="button" role="tab" aria-controls="parallel-tab-pane" aria-selected="false">Parallel Registers</button>
            </li>
        }
        @if (UIComponents.SerialPort)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="serial-tab" data-bs-toggle="tab" data-bs-target="#serial-tab-pane" type="button" role="tab" aria-controls="serial-tab-pane" aria-selected="false">Serial Port</button>
            </li>
        }
        @if (UIComponents.Library && Library != null)
        {
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="library-tab" data-bs-toggle="tab" data-bs-target="#library-tab-pane" type="button" role="tab" aria-controls="library-tab-pane" aria-selected="false">@Library[0]</button>
            </li>
        }
        <li class="nav-item ms-auto" role="presentation" @onclick="quack">
            <button class="nav-link duck" id="duck-tab"><img src="img/reginald.png" class="duckImg" alt="duck!"></button>
        </li>
    </ul>

    <div class="tab-content">
        @if (UIComponents.WSIMInstructions && WSIMInstructions != null)
        {
            <div class="tab-pane fade show active" id="instructions-tab-pane" role="tabpanel" aria-labelledby="instructions-tab" tabindex="0">
                @WSIMInstructions
            </div>
            <div class="tab-pane fade" id="code-tab-pane" role="tabpanel" aria-labelledby="code-tab" tabindex="0">
                <p id="wsimCode"></p>
            </div>
        }
        else
        {
            <div class="tab-pane fade show active" id="code-tab-pane" role="tabpanel" aria-labelledby="code-tab" tabindex="0">
                <p id="wsimCode"></p>
            </div>
        }
        @if (UIComponents.GPRegisters)
        {
            <div class="tab-pane fade" id="gp-tab-pane" role="tabpanel" aria-labelledby="gp-tab" tabindex="0">
                <Registers CPU="@board.CPU" registerType="@RegisterType.GP"/>
            </div>
        }
        @if (UIComponents.SPRegisters)
        {
            <div class="tab-pane fade" id="sp-tab-pane" role="tabpanel" aria-labelledby="sp-tab" tabindex="0">
                <Registers CPU="@board.CPU" registerType="@RegisterType.SP"/>
            </div>
        }
        @if (UIComponents.RAM)
        {
            <div class="tab-pane fade mDevice" id="ram-tab-pane" role="tabpanel" aria-labelledby="ram-tab" tabindex="0">
                <Memory CPU="@board.CPU" mDevice="@board.RAM" wordsLoaded="@finalAddress" labels="@labels"/>
            </div>
        }
        @if (UIComponents.ParallelRegisters)
        {
            <div class="tab-pane fade" id="parallel-tab-pane" role="tabpanel" aria-labelledby="parallel-tab" tabindex="0">
                <PeripheralMemory parallelMemory="@board.Parallel"/>
            </div>
        }
        @if (UIComponents.SerialPort)
        {
            <div class="tab-pane fade" id="serial-tab-pane" role="tabpanel" aria-labelledby="serial-tab" tabindex="0">
                @* <SerialPort @ref="serialPort" serial="@board.Serial1"/> *@
                <p>@board.Serial1.serialText</p>
            </div>
        }
        @if (UIComponents.Library && Library != null)
        {
            <div class="tab-pane fade" id="library-tab-pane" role="tabpanel" aria-labelledby="library-tab" tabindex="0">
                <pre>@((MarkupString)Library[1])</pre>
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public EventCallback CompileRequested { get; set; }

    [Parameter]
    public EventCallback BoardChanged { get; set; }

    [Parameter]
    required public UIComponents UIComponents { get; set; }

    [Parameter]
    public RenderFragment? WSIMInstructions { get; set; }

    [Parameter]
    public string[]? Library { get; set; }

    public enum ExceptionSource { GPF = 0x1000, SYSCALL = 0x2000, BREAK = 0x4000, ARITH = 0x8000 }

    public List<BoardState> memoryStates = new List<BoardState>();
    public List<BoardState> gpRegisterStates = new List<BoardState>();
    public List<BoardState> spRegisterStates = new List<BoardState>();
    public List<BoardState> serialStates = new List<BoardState>();
    public List<BoardState> interruptStates = new List<BoardState>();
    public List<BoardState> pRegisterStates = new List<BoardState>();
    public List<BoardState> pcStates = new List<BoardState>();

    @* TODO: Add serial backup states *@
    @* TODO: Add .equ block *@
    @* TODO: Look at RAM stack display  *@
    @* TODO: Add ability to disable WSIM section for empty webpage *@
    @* TODO: Option to not display code *@
    @* TODO: Option to put in custom render fragement instead of WSIM component *@
    @* TODO: Allow tabs + new blockly blocks to be shown and hidden mid level *@

    required public string[] blockIDs;
    required public List<string> labels;

    public static string EQUString = """
    .equ sp1_tx,		0x70000
    .equ sp1_rx,		0x70001
    .equ sp1_ctrl,		0x70002
    .equ sp1_stat,		0x70003
    .equ sp1_iack,		0x70004

    .equ par_switch,	0x73000
    .equ par_btn,		0x73001
    .equ par_ctrl,		0x73004
    .equ par_iack,		0x73005
    .equ par_ulssd,		0x73006
    .equ par_urssd,		0x73007
    .equ par_llssd,		0x73008
    .equ par_lrssd,		0x73009
    .equ par_led,       0x7300A
    """;

    //WSIM Operation
    public RexBoard board = new RexBoard();
    uint finalAddress = 50;

    bool instructionsLoaded = false;
    public bool running = false;

    private DotNetObjectReference<WSIM>? dotNetReference;
    private CancellationTokenSource? cts;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            //Load SSDs on page load
            updateSSDs();

            //Initialise tooltips, popovers, and set the theme
            await JSRuntime.InvokeVoidAsync("initPopper");
            await JSRuntime.InvokeVoidAsync("initTheme");

            //Create a DotNet object reference to allow InvokeBoardChanged() to be called from JS code
            dotNetReference = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setDotNetRef", dotNetReference);

            board.Serial1.SerialDataTransmitted -= storeSerial;
            board.Serial1.SerialDataTransmitted += storeSerial;

            //Reset the Blockly UI to prevent any lingering UI between page changes.
            await JSRuntime.InvokeVoidAsync("resetUI");
            StateHasChanged();
        }
    }

    //Dispose the DotNet object reference as needed
    public void Dispose()
    {
        dotNetReference?.Dispose();
        cts?.Cancel();
        cts?.Dispose();
    }

    public async Task OnCompileClicked()
    {
        if (UIComponents.Blockly)
        {
            await CompileRequested.InvokeAsync();
        }
        else
        {
            await Compile(("", [], new List<String>()));
        }
    }

    //Take a .s file onclickfrom the user and compile it to an SREC for use in the wsim
    public async Task Compile((string code, string[] IDs, List<string> labels) args)
    {
        //Get block IDs, labels, and plain text code from args
        blockIDs = args.IDs;
        labels = args.labels;

        //Reset board
        Reset();

        byte[] codeBytes;

        string codeWithEQUs = args.code + "\n" + EQUString;

        if (Library != null)
        {
            string htmlTags = @"<table>|</table>|<tr>|</tr>|<td>|</td>\n";
            string libraryCode = Regex.Replace(Library[1], htmlTags, "");
            string combinedCode = codeWithEQUs + "\n" + libraryCode;
            codeBytes = Encoding.UTF8.GetBytes(combinedCode);
        }
        else
        {
            codeBytes = Encoding.UTF8.GetBytes(codeWithEQUs);
        }

        try
        {
            //Call assembleAndLink from app.js to compile the .s file and retrieve the resulting .srec file as bytes
            byte[] srecBytes = await JSRuntime.InvokeAsync<byte[]>("assembleAndLink", "input.s", codeBytes);
            await JSRuntime.InvokeVoidAsync("clearPopover");
            //Open a new memory stream, and pass to wsim for execution
            MemoryStream ms = new MemoryStream(srecBytes);
            finalAddress = await board.LoadSrecAsync(ms);
            if (finalAddress != 0)
            {
                instructionsLoaded = true;
                await JSRuntime.InvokeVoidAsync("highlightBlock", blockIDs[0]);
            }
            StateHasChanged();
        }
        catch {
            labels.Clear();
        }
    }

    public void Reset()
    {
        board.Reset();
        running = false;

        //Remove any stored states
        memoryStates.Clear();
        gpRegisterStates.Clear();
        spRegisterStates.Clear();
        serialStates.Clear();
        pcStates.Clear();
        interruptStates.Clear();
        pRegisterStates.Clear();

        //Update UI
        updateSSDs();
        updateLEDs();
        updateSwitches();
        StateHasChanged();
        BoardChanged.InvokeAsync();
    }

    //Executes a single instruction
    async Task Step()
    {
        if (instructionsLoaded == true)
        {
            cts = new CancellationTokenSource();
            await WSIMWorker(true, cts.Token);
        }
    }

    //Continuously executes instructions
    async Task Run()
    {
        if (instructionsLoaded == true)
        {
            cts = new CancellationTokenSource();
            await WSIMWorker(false, cts.Token);
        }
    }

    //Pause execution of instructions
    void Pause()
    {
        running = false;
    }

    async Task WSIMWorker(bool stepping, CancellationToken token)
    {
        running = true;
        try
        {
            while (running && !token.IsCancellationRequested)
            {
                //Only do one cycle if the step button was clicked
                running ^= stepping;
                //Catch any system exceptions
                switch (board.CPU.InterruptStatus & (uint)0xF000)
                {
                    case (uint)ExceptionSource.GPF:
                        running = false;
                        await JSRuntime.InvokeVoidAsync("triggerPopover", board.CPU.PC > finalAddress ? "GPF thrown! Have you tried adding an $ra?" : "GPF thrown!");
                        await BoardChanged.InvokeAsync();
                        break;
                    case (uint)ExceptionSource.SYSCALL:
                        running = false;
                        await JSRuntime.InvokeVoidAsync("triggerPopover", "Syscall exception thrown!");
                        await BoardChanged.InvokeAsync();
                        break;
                    case (uint)ExceptionSource.BREAK:
                        running = false;
                        await JSRuntime.InvokeVoidAsync("triggerPopover", "Breakpoint exception thrown!");
                        await BoardChanged.InvokeAsync();
                        break;
                    case (uint)ExceptionSource.ARITH:
                        running = false;
                        await JSRuntime.InvokeVoidAsync("triggerPopover", "Arithmetic exception thrown!");
                        await BoardChanged.InvokeAsync();
                        break;
                    default:
                        //Stop if the user used jr $ra
                        if (board.CPU.PC == 0xFFFFF)
                        {
                            running = false;
                            break;
                        }

                        //Store board state
                        StoreBoardState();

                        //Execute next instruction
                        while(!board.Tick());

                        //Invoke the EventCallback to allow the Level to check any changes to the board state to see if an objective has been completed
                        await BoardChanged.InvokeAsync();

                        //Highlight next block to be executed (try catch used to account for library code which is un-highlightable)
                        try
                        {
                            await JSRuntime.InvokeVoidAsync("highlightBlock", blockIDs[board.CPU.PC]);
                        }
                        catch
                        {
                            await JSRuntime.InvokeVoidAsync("highlightBlock", null);
                        }

                        //Update SSDs & LEDs
                        updateSSDs();
                        updateLEDs();
                        updateSwitches();

                        //Update UI, and add a delay between instructions
                        await InvokeAsync(StateHasChanged);
                        await Task.Delay(100);
                        break;
                }
            }
        }
        catch (OperationCanceledException) {}
    }

    //Used to check the state of the WRAMP board
    public bool Verify(BoardCheck boardCheck)
    {
        if (boardCheck.component != null)
        {
            switch (boardCheck.component)
            {
                case WRAMPComponents c when (int)c >= 0 && (int) c < 11:
                    return CheckStateList(boardCheck, pRegisterStates, (int)boardCheck.component);
                case WRAMPComponents.GPRegisters:
                    return CheckStateList(boardCheck, gpRegisterStates, (int)boardCheck.checkIndex!);
                case WRAMPComponents.SPRegisters:
                    return CheckStateList(boardCheck, spRegisterStates, (int)boardCheck.checkIndex!);
                case WRAMPComponents.RAM:
                    return CheckStateList(boardCheck, memoryStates, (int)boardCheck.checkIndex!);
                default:
                    return false;
            }
        }
        else if (boardCheck.components != null)
        {
            foreach (WRAMPComponents component in boardCheck.components)
            {
                switch (boardCheck.component)
                {
                    case WRAMPComponents c when (int)c >= 0 && (int) c < 11:
                        if(!CheckStateList(boardCheck, pRegisterStates, (int)boardCheck.component))
                        {
                            return false;
                        }
                        break;
                    case WRAMPComponents.GPRegisters:
                        if(!CheckStateList(boardCheck, gpRegisterStates, (int)boardCheck.checkIndex!))
                        {
                            return false;
                        }
                        break;
                    case WRAMPComponents.SPRegisters:
                        if(!CheckStateList(boardCheck, spRegisterStates, (int)boardCheck.checkIndex!))
                        {
                            return false;
                        }
                        break;
                    case WRAMPComponents.RAM:
                        if(!CheckStateList(boardCheck, memoryStates, (int)boardCheck.checkIndex!))
                        {
                            return false;
                        }
                        break;
                    default:
                        return false;
                }
            }
            return true;
        }
        return false;
    }

    bool CheckStateList(BoardCheck boardCheck, List<BoardState> states, int componentIndex)
    {
        StoreBoardState();
        if (boardCheck.start != null && boardCheck.end != null)
        {
            List<uint> values = getSummaryStateList(componentIndex, states);

            if (values.Count <= Math.Abs((int)(boardCheck.end - boardCheck.start)))
            {
                ClearNewestState();
                return false;
            }

            int pos = 1;
            for (int i = (int)boardCheck.end; i >= boardCheck.start; i--)
            {
                if (values[^pos] != i)
                {
                    ClearNewestState();
                    return false;
                }
                pos++;
            }
        }
        if (boardCheck.value != null)
        {
            if (states[^1].Keys![componentIndex] != boardCheck.value)
            {
                ClearNewestState();
                return false;
            }
        }
        if (boardCheck.values != null)
        {
            List<uint> values = getSummaryStateList(componentIndex, states);
            List<uint> answers = boardCheck.values;
            if (values.Count >= answers.Count)
            {
                values.RemoveRange(0, values.Count - answers.Count);

                if (!answers.SequenceEqual(values))
                {
                    ClearNewestState();
                    return false;
                }
            }
            else
            {
                ClearNewestState();
                return false;
            }
        }
        ClearNewestState();
        return true;
    }

    List<uint> getSummaryStateList(int componentIndex, List<BoardState> states)
    {
        List<uint> values = new List<uint>();
        uint next = 0;

        foreach (BoardState state in states)
        {
            if (state.Keys != null)
            {
                next = state.Keys[componentIndex];
            }
            else if (state.Key != null)
            {
                next = (uint)state.Key;
            }

            if (values.Count == 0 || values.Last() != next)
            {
                values.Add(next);
            }
        }
        return values;
    }

    void StoreBoardState()
    {
        //Store board state, either creating a new entry if it is unique, or incrementing the repeat value for the previous state
        if (memoryStates.Count == 0 || !memoryStates[^1].Keys.SequenceEqual(board.RAM.mMemory))
        {
            memoryStates.Add(new BoardState ((uint[])board.RAM.mMemory.Clone()));
        }
        else
        {
            memoryStates[^1].Repeats++;
        }
        if (gpRegisterStates.Count == 0 || !gpRegisterStates[^1].Keys.SequenceEqual(board.CPU.mGpRegisters.mRegisters))
        {
            gpRegisterStates.Add(new BoardState ((uint[])board.CPU.mGpRegisters.mRegisters.Clone()));
        }
        else
        {
            gpRegisterStates[^1].Repeats++;
        }
        if (spRegisterStates.Count == 0 || !spRegisterStates[^1].Keys.SequenceEqual(board.CPU.mSpRegisters.mRegisters))
        {
            spRegisterStates.Add(new BoardState ((uint[])board.CPU.mSpRegisters.mRegisters.Clone()));
        }
        else
        {
            spRegisterStates[^1].Repeats++;
        }
        if (serialStates.Count == 0 || serialStates[^1].String != board.Serial1.serialText || !serialStates[^1].Keys.SequenceEqual(board.Serial1.mMemory))
        {
            serialStates.Add(new BoardState(board.Serial1.serialText, (uint[])board.Serial1.mMemory.Clone()));
        }
        else
        {
            serialStates[^1].Repeats++;
        }
        if (interruptStates.Count == 0 || interruptStates[^1].Key != board.CPU.InterruptStatus)
        {
            interruptStates.Add(new BoardState (board.CPU.InterruptStatus));
        }
        else
        {
            interruptStates[^1].Repeats++;
        }
        if (pRegisterStates.Count == 0 || !pRegisterStates[^1].Keys.SequenceEqual(board.Parallel.mMemory))
        {
            pRegisterStates.Add(new BoardState((uint[])board.Parallel.mMemory.Clone()));
        }
        else
        {
            pRegisterStates[^1].Repeats++;
        }
        if (pcStates.Count == 0 || pcStates[^1].Key != board.CPU.PC)
        {
            pcStates.Add(new BoardState(board.CPU.PC));
        }
        else
        {
            pcStates[^1].Repeats++;
        }
    }

    void storeSerial(object? sender, SerialIO.SerialEventArgs e)
    {
    }

    //Go back one board state
    void Undo()
    {
        //If there is a state to revert to
        if (pcStates.Count != 0)
        {
            running = false;

            //Restore previous states
            board.RAM.mMemory = (uint[])memoryStates[^1].Keys!.Clone();
            board.CPU.mGpRegisters.mRegisters = (uint[])gpRegisterStates[^1].Keys!.Clone();
            board.CPU.mSpRegisters.mRegisters = (uint[])spRegisterStates[^1].Keys!.Clone();
            board.CPU.InterruptStatus = (uint)interruptStates[^1].Key!;
            board.CPU.mPC = (uint)pcStates[^1].Key!;
            board.Parallel.mMemory = (uint[])pRegisterStates[^1].Keys!.Clone();

            board.Serial1.serialText = serialStates[^1].String!;
            board.Serial1.mMemory = (uint[])serialStates[^1].Keys!.Clone();

            //Highlight previous block (try catch used to account for library code which is un-highlightable due to not being in the Blockly workspace)
            try
            {
                JSRuntime.InvokeVoidAsync("highlightBlock", blockIDs[board.CPU.PC]);
            }
            catch {}

            //Remove restored states from list or decrement number of repeats
            if (--memoryStates[^1].Repeats < 0)
            {
                memoryStates.RemoveAt(memoryStates.Count - 1);
            }
            if (--gpRegisterStates[^1].Repeats < 0)
            {
                gpRegisterStates.RemoveAt(gpRegisterStates.Count - 1);
            }
            if (--spRegisterStates[^1].Repeats < 0)
            {
                spRegisterStates.RemoveAt(spRegisterStates.Count - 1);
            }
            if (--serialStates[^1].Repeats < 0)
            {
                serialStates.RemoveAt(serialStates.Count - 1);
            }
            if (--interruptStates[^1].Repeats < 0)
            {
                interruptStates.RemoveAt(interruptStates.Count - 1);
            }
            if (--pRegisterStates[^1].Repeats < 0)
            {
                pRegisterStates.RemoveAt(pRegisterStates.Count - 1);
            }
            if (--pcStates[^1].Repeats < 0)
            {
                pcStates.RemoveAt(pcStates.Count - 1);
            }

            //Update UI
            updateLEDs();
            updateSSDs();
            updateSwitches();
            StateHasChanged();
        }
    }

    void ClearNewestState()
    {
        //Remove new state from list or decrement number of repeats
        if (--memoryStates[^1].Repeats < 0)
        {
            memoryStates.RemoveAt(memoryStates.Count - 1);
        }
        if (--gpRegisterStates[^1].Repeats < 0)
        {
            gpRegisterStates.RemoveAt(gpRegisterStates.Count - 1);
        }
        if (--spRegisterStates[^1].Repeats < 0)
        {
            spRegisterStates.RemoveAt(spRegisterStates.Count - 1);
        }
        if (--interruptStates[^1].Repeats < 0)
        {
            interruptStates.RemoveAt(interruptStates.Count - 1);
        }
        if (--pRegisterStates[^1].Repeats < 0)
        {
            pRegisterStates.RemoveAt(pRegisterStates.Count - 1);
        }
        if (--pcStates[^1].Repeats < 0)
        {
            pcStates.RemoveAt(pcStates.Count - 1);
        }
    }

    async Task toggleSwitch(int pos)
    {
        StoreBoardState();
        board.Parallel.Switches ^= (1u << pos);
        await BoardChanged.InvokeAsync();
    }

    async Task pressButton(int pos)
    {
        StoreBoardState();
        board.Parallel.Buttons = (uint)1 << pos;
        await BoardChanged.InvokeAsync();
    }

    void releaseButton()
    {
        StoreBoardState();
        board.Parallel.Buttons = 0;
    }

    void updateSSDs()
    {
        uint[] SSD_DECODE = { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x7, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };
        uint[] values = {board.Parallel.LeftLeftSSD, board.Parallel.LeftRightSSD, board.Parallel.LeftSSD, board.Parallel.RightSSD};
        string[] IDs = {"sevenSegOne", "sevenSegTwo", "sevenSegThree", "sevenSegFour"};
        //If Hex-decode is enabled
        if ((board.Parallel.Control & 1) == 1)
        {
            for (int i = 0; i < values.Length; i++)
            {
                uint value = values[i] & 0xF;
                uint segments = SSD_DECODE[value];
                for (int i2 = 0; i2 < 8; i2++)
                {
                    uint bit = segments & 1;
                    JSRuntime.InvokeVoidAsync("changeSegment", IDs[i], i2, bit);
                    segments >>= 1;
                }
            }
        }
        else
        {
            for (int i = 0; i < values.Length; i++)
            {
                for (int i2 = 0; i2 < 8; i2++)
                {
                    uint bit = values[i] & 1;;
                    JSRuntime.InvokeVoidAsync("changeSegment", IDs[i], i2, bit);
                    values[i] >>= 1;
                }
            }
        }
    }

    void updateLEDs()
    {
        uint LEDValues = board.Parallel.Leds;
        for (int i = 0; i < 16; i++)
        {
            string ID = "led" + i;
            uint value = LEDValues & 1;
            JSRuntime.InvokeVoidAsync("changeLED", ID, value);
            LEDValues >>= 1;
        }
    }

    void updateSwitches()
    {
        uint switchValues = board.Parallel.Switches;
        for (int i = 0; i < 16; i++)
        {
            string ID = "switch" + i;
            uint value = switchValues & 1;
            JSRuntime.InvokeVoidAsync("changeSwitch", ID, value);
            switchValues >>= 1;
        }
    }

    void quack()
    {
        JSRuntime.InvokeVoidAsync("quacker");
    }

    void saveCode()
    {
        JSRuntime.InvokeVoidAsync("saveCode");
    }

    [JSInvokable]
    public async Task InvokeBoardChanged()
    {
        await BoardChanged.InvokeAsync();
    }
}