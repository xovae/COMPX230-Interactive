@page "/levelTwo"
@using RexSimulator.Hardware
@inject IJSRuntime JSRuntime

<Level @ref="levelComponent" Title="Level Two" LevelName="levelTwo" UIComponents="@Components" MainInstructions="@MainInstructions" Library="@Library"/>

@code {
    public Level? levelComponent;
    required public RexBoard board;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && levelComponent != null && levelComponent.wsimComponent != null)
        {
            board = levelComponent.wsimComponent.board;
        }
    }

    public UIComponents Components = new UIComponents(Blockly: false, GPRegisters: true, SSDs: true, ParallelRegisters: true, Library: true, RAM: true);

    public int section = 0;

    public RenderFragment MainInstructions =>
    @<div>
        <h1>Hello World!</h1>
        <ul>
            <li>On the right side of the screen is a simulator that is showing the internal RAM and LED display of a basys3 board.</li>
            <li>Currently loaded into RAM is a WRAMP program that will display a message on the LEDs.</li>
            <li>You can use the COMPILE button to get things started, then use the RUN and STEP buttons to simulate running this program</li>
            <li>What message is being displayed?</li>


            <input id="inputOne" @oninput="OnInputMessageChanged" placeholder="Enter message"/>
            <label class="inputCheckmark" id="inputOneCheckmark" for="inputOne">✔</label>


            @if (section >= 1)
            {
                <li>That's right!</li>
                <li>This simulation is slow so that you can see each SSD update individually</li>
                <li>On the real board, you need to include an artifial delay to make it human readable</li>

                <li>If you're interested, try switching to the RAM tab to see the program running.</li>
                <li>Can you find where the message is stored?</li>
                <li>What address in RAM is the letter 'H' stored in?</li>

                <input id="inputTwo" @oninput="OnInputAddressChanged" placeholder="Enter message"/>
                <label class="inputCheckmark" id="inputTwoCheckmark" for="inputTwo">✔</label>
            }
            @if (section >= 2)
            {
                <li>Correct!</li>
                <li>The 'Disassembly' column shows the WRAMP instruction that is disassembled from the value 0x00000076</li>
                <li>Because everything is just made of 0s and 1s, the same number that represents 'H' may also be an 'add' instruction!</li>
                JSRuntime.InvokeVoidAsync("levelCompleted");
            }
        </ul>
    </div>;

    public void OnInputMessageChanged(ChangeEventArgs e)
    {
        string userInput = e.Value?.ToString() ?? "";
        if (userInput.Trim().ToUpper() == "HELLO 230" || userInput.Trim().ToUpper() == "HELLO230")
        {
            if(section == 0) section++;
            JSRuntime.InvokeVoidAsync("objectiveCheck", "inputOneCheckmark");
        }
    }

    public void OnInputAddressChanged(ChangeEventArgs e)
    {
        string userInput = e.Value?.ToString() ?? "";
        if (userInput.Trim() == "10" || userInput.Trim() == "00000010" || userInput.Trim() == "0x00000010")
        {
            if (section == 1) section++;
            JSRuntime.InvokeVoidAsync("objectiveCheck", "inputTwoCheckmark");
        }
    }

    public string[] Library = { "hello.s", """
    .text				        #specifies that what follows are instructions
    .global main		        #specifies that the label "main" is globally accessible

    main:				        #entry point into the program
        sw $0, 0x73004($0)	    #enable individual control of SSD segments
        addi $2, $0, 0		    #initialise loop counter to zero

    loop:
        seqi $8, $2, 12		    #has the loop finished?
        bnez $8, main		    #if so, go to "main"
        jal write		        #write the pattern to the SSD
        addi $2, $2, 1		    #increment loop counter
        j loop			        #go around again

    write:
        lw $1, 0x73007($0)      # transfer SSD contents to the left
        sw $1, 0x73006($0)
        lw $1, 0x73008($0)
        sw $1, 0x73007($0)
        lw $1, 0x73009($0)
        sw $1, 0x73008($0)
        lw $1, hello($2)	    #load the new pattern to the rightmost SSD
        sw $1, 0x73009($0)
        jr $ra			        #return

    .data				        #specifies that what follows are data with initial values
    hello:
        .word 0x76 #H
        .word 0x79 #E
        .word 0x38 #L
        .word 0x38 #L
        .word 0x3F #O
        .word 0x00
        .word 0x5B #2
        .word 0x4F #3
        .word 0x3F #0
        .word 0x00
        .word 0x00
        .word 0x00
    """ };

}