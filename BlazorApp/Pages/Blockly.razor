@using System.Text.RegularExpressions
@inject IJSRuntime JSRuntime

<div class="btn-group mb-2" role="group" aria-label="Code Controls">
    <button type="button" class="btn btn-warning" @onclick="saveWorkspace">Save</button>
    <label class="btn btn-info">Load
        <InputFile hidden id="workspaceInput" OnChange="loadWorkspace"/>
    </label>
</div>

<div id="blocklyDiv"></div>

@code {
    [Parameter]
    public EventCallback<(string, string[], List<string>)> Exported { get; set; }

    [Parameter]
    required public string Toolbox { get; set; }

    [Parameter]
    public string? maxInstances { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("initBlockly", Toolbox, maxInstances);
            await JSRuntime.InvokeVoidAsync("initUpdate");
            await JSRuntime.InvokeVoidAsync("initBlocklyTheme");
            StateHasChanged();
        }
    }

    public async Task Export()
    {
        string code = await JSRuntime.InvokeAsync<string>("generateCode");
        await JSRuntime.InvokeVoidAsync("updateCode", "Compile");
        string highlightBlockPattern = @"highlightBlock\('([^']+)'\)\n\t";

        if (code.Contains("main:") && code.Contains(".global main") && code.Contains(".text"))
        {
            //Remove highlightBlock() from any lines that aren't WRAMP instructions
            code = Regex.Replace(code, highlightBlockPattern + @"\.text", ".text");
            code = Regex.Replace(code, highlightBlockPattern + @"\.data", ".data");
            code = Regex.Replace(code, highlightBlockPattern + @"\.bss", ".bss");
            code = Regex.Replace(code, highlightBlockPattern + @"\.global main", ".global main");

            //Removes highlightBlock() from labels
            code = Regex.Replace(code, highlightBlockPattern + @"LABEL([a-zA-Z0-9_.]+):", "$2:");

            //Extracts the ID of each block that can be executed in WRAMP for highlighting them in the Blockly workspace
            string[] highlightStatements = Regex.Matches(code, highlightBlockPattern).Cast<Match>().Select(m => m.Groups[1].Value.Trim()).ToArray();
            code = Regex.Replace(code, highlightBlockPattern, String.Empty);

            //Get every label name and position for display in WSIM
            string[] lines = code.Split(Environment.NewLine);
            List<string> labels = new List<string>();
            for (int i = 0; i < lines.Length; i++)
            {
                if (!Regex.IsMatch(lines[i], @"^([a-zA-Z0-9_.]+):$"))
                {
                    if (lines[i] != ".text" && lines[i] != ".data" && lines[i] != ".bss" && lines[i] != ".global main")
                    {
                        labels.Add("");
                    }
                }
                else
                {
                    //Remove the previous whitespace entry (if it exists) to make the position of the label match up with it's proceeding instruction
                    if (labels.Count > 1) labels.RemoveAt(labels.Count - 1);
                    labels.Add(Regex.Replace(lines[i], @"^([a-zA-Z0-9_.]+):$", "$1"));
                }
            }
            await Exported.InvokeAsync((code, highlightStatements, labels));
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("triggerPopover", "You must declare a .text segment with global main, and a label for main!");
        }
    }

    async Task saveWorkspace()
    {
        await JSRuntime.InvokeVoidAsync("saveWorkspace");
    }

    async Task loadWorkspace(InputFileChangeEventArgs e)
    {
        try
        {
            string workspaceJSON;
            using (Stream s = e.File.OpenReadStream())
            {
                using (StreamReader sr = new StreamReader(s))
                {
                    workspaceJSON = await sr.ReadToEndAsync();
                    await JSRuntime.InvokeVoidAsync("loadWorkspace", workspaceJSON);
                }
            }
        }
        catch {}
    }
}
