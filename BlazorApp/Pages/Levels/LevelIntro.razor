@page "/levelIntro"
@using RexSimulator.Hardware
@using System.Security.Permissions
@inject IJSRuntime JSRuntime

<Level @ref="levelComponent" Title="Introduction" BoardChanged="CheckBoard" Toolbox="@toolbox" maxInstances="@maxInstances" UIComponents="@UIComponents" WSIMInstructions="@Instructions"/>

@code {
    public Level? levelComponent;
    public LevelComponents lc = new LevelComponents();
    required public WSIM WSIM;

    required public RexBoard board;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (levelComponent != null && levelComponent.wsimComponent != null)
            {
                board = levelComponent.wsimComponent.board;
                WSIM = levelComponent.wsimComponent;
            }

            lc.SetJSRuntime(JSRuntime);
            await lc.getProgress();
            StateHasChanged();
        }
    }

    public UIComponents UIComponents = new UIComponents(Blockly: true, Code: true, GPRegisters: true);

    public RenderFragment Instructions =>
    @<div>
        <h1>Writing WRAMP code using blockly!</h1>
        <ul>
            @if (lc.Section >= 0)
            {
                <li>On the left side of the screen is a blockly workspace.</li>
                <li>You can click on the sections to find WRAMP code blocks, try adding a .text to the workspace.</li>
                <li>This will be the start of your WRAMP code.</li>
            }

            @if (lc.Section >= 1)
            {
                <li>Every WRAMP program needs a .text section and a "main" label that identifies the start of the program.<label class="inputCheckmark" id="checkmarkS1Main"><i class="bi bi-check-lg"></i></label></li>
                <li>You should also make the main label be visible from the outside by adding <code>.global main</code><label class="inputCheckmark" id="checkmarkS1Global"><i class="bi bi-check-lg"></i></label></li>
                <li>Finally, to successfully finish your program should jump return to the $ra return address.<label class="inputCheckmark" id="checkmarkS1JR"><i class="bi bi-check-lg"></i></label></li>
            }

            @if (lc.Section >= 2)
            {
                <li> This will be the basic setup for all WRAMP programs. Try saving it now so you can reuse it later.</li>
                <li> Finally, try to put the number 1 into register 1 using the addi block, then compile and run your code to see if it works properly. </li>
                <table class="table objectiveTable">
                    <tr>
                        <td>addi block added</td>
                        <td><label class="inputCheckmark" id="checkmark2Addi"><i class="bi bi-check-lg"></i></label></td>
                    </tr>
                    <tr>
                        <td>Program compiled and running</td>
                        <td><label class="inputCheckmark" id="checkmark2Running"><i class="bi bi-check-lg"></i></label></td>
                    </tr>
                    <tr>
                        <td>Register 1 contains value 1</td>
                        <td><label class="inputCheckmark" id="checkmark2Register"><i class="bi bi-check-lg"></i></label></td>
                    </tr>
                </table>
            }

            @if (lc.Section >= 3)
            {
                <li> Great work! You've completed this level. </li>
                <li> Next, you can choose a different level in the sidebar on the left to continue. </li>
                JSRuntime.InvokeVoidAsync("levelCompleted");
            }
        </ul>
    </div>;

    public async Task CheckBoard()
    {
        string code = await GetUserCode();
        if (lc.Section == 0)
        {
            if (code.Contains(".text")) lc.Section++;
        }
        if (lc.Section == 1)
        {
            bool main = code.Contains("main:");
            bool global = code.Contains(".global main");
            bool returned = code.Contains("jr $ra");

            //Check objectives
            CheckObjective(main, "checkmarkS1Main");
            CheckObjective(global, "checkmarkS1Global");
            CheckObjective(returned, "checkmarkS1JR");

            if (main && global && returned)
            {
                lc.Section++;
            }
        }
        if (lc.Section == 2)
        {
            bool addi = code.Contains("addi");
            bool running = WSIM.running;
            bool register1 = WSIM.Verify(new BoardCheck(WRAMPComponents.GPRegisters, 1, 1));

            CheckObjective(addi, "checkmark2Addi");
            CheckObjective(register1, "checkmark2Register");
            CheckObjective(running, "checkmark2Running");

            if (addi && running && register1)
            {
                lc.Section++;
            }
        }
    }

    public void CheckObjective(bool goal, string checkmarkID)
    {
        JSRuntime.InvokeVoidAsync(goal ? "objectiveCheck" : "objectiveUncheck", checkmarkID);
    }

    public async Task<string> GetUserCode()
    {
        return await JSRuntime.InvokeAsync<string>("getGeneratedCode");
    }


    public Toolbox toolbox = new Toolbox{
        contents = new List<Category>() {
            new Category {
                name = "Sections",
                categorystyle = "sectionCategory",
                contents = new List<Block>() {
                    new Block { type = "textHead" },
                    new Block { type = "global" }
                }
            },
            new Category {
                name = "Branch",
                categorystyle = "branchCategory",
                contents = new List<Block>() {
                    new Block { type = "label" },
                    new Block { type = "jumpRegister" }
                }
            },
            new Category {
                name = "Arithmetic",
                categorystyle = "arithmeticCategory",
                contents = new List<Block>() {
                    new Block { type = "arithmeticImmediate" }
                }
            }
        }
    };

    public string maxInstances = "{ 'textHead': 1}";
}