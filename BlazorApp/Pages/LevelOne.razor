@page "/levelOne"
@using RexSimulator.Hardware
@inject IJSRuntime JSRuntime

<Level @ref="levelComponent" Title="Level One" BoardChanged="CheckBoard" LevelName="levelOne" Toolbox="@toolbox" UIComponents="@UIComponents" WSIMInstructions="@Instructions"/>

@code {
    public Level? levelComponent;
    required public WSIM WSIM;

    required public RexBoard board;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender && levelComponent != null && levelComponent.wsimComponent != null)
        {
            board = levelComponent.wsimComponent.board;
            WSIM = levelComponent.wsimComponent;
        }
    }

    public bool needsReturn = true;

    public UIComponents UIComponents = new UIComponents(Blockly: true, WSIMInstructions: true, SSDs: true, Switches: true, LEDs: true, ParallelRegisters: true);

    public int section = 0;

    public RenderFragment Instructions =>
    @<div>
        <h1>Welcome!</h1>
        <ul>
            <li>On the right side of the screen is a display showing the physical components of the WRAMP board.</li>
            <li>You can click on the switches and buttons to change the values stored in the Parallel Registers tab.</li>
            <li>Which memory address contains the value of the switches?</li>

            <input id="inputOne" @oninput="OnInputChanged" placeholder="Enter address"/>
            <label class="inputCheckmark" id="inputOneCheckmark" for="inputOne">✔</label>

            @if (section >= 1)
            {
                <li>That's correct!</li>
                <li id="switchOne">Next, can you toggle the switches such that this value has the decimal value 10?</li>
                <label class="inputCheckmark" id="switchCheckmark" for="switchOne">✔</label>
            }

            @if (section >= 2)
            {
                <li> Great work! </li>
                <li> Next, write some blockly code to light up the LEDs above the switches. </li>
                <li> You can write a value to these using the sw (store word) instruction and using the memory address 0x7300A </li>
                <li> Can you light up all the LEDs at once? </li>
            }

            @if (section >= 3)
            {
                <li> Finally, can you load the value from the switches and store it into the leds? </li>
                <li> You'll need to use both the lw and sw instructions. </li>
                <li> Note that you can't move the value directly from one address to another, you'll need to temporarily store it in a register. </li>
            }

            @if (section >= 4)
            {
            <li> To test that it is working properly, try switching different switches and watch the corresponding LED light up.  </li>
                <li> You may need to add a loop back to the start to have it continually update.  </li>
            }
        </ul>
    </div>;

    public void OnInputChanged(ChangeEventArgs e)
    {
        string userInput = e.Value?.ToString() ?? "";
        if (userInput == "73000" || userInput == "00073000" || userInput == "0x73000")
        {
            if(section == 0) section++;
            JSRuntime.InvokeVoidAsync("objectiveCheck", "inputOneCheckmark");
        }
    }

    public async Task CheckBoard()
    {

        switch (section)
        {
            case 1:
                if (WSIM.Verify(new BoardCheck(WRAMPComponents.Switches, 10)))
                {
                    await JSRuntime.InvokeVoidAsync("objectiveCheck", "switchCheckmark");
                    section++;
                    StateHasChanged();
                }
                break;
            case 2:
                if (WSIM.Verify(new BoardCheck(WRAMPComponents.LEDs, 65535)) || WSIM.Verify(new BoardCheck(WRAMPComponents.LEDs, 4294967295)))
                {
                    section++;
                    StateHasChanged();
                }
                break;
            case 3:
                if (WSIM.Verify(new BoardCheck(WRAMPComponents.LEDs, 65535)) && WSIM.Verify(new BoardCheck(WRAMPComponents.Switches, 65535)))
                {
                    section++;
                    StateHasChanged();
                }
                break;
        }
    }

    public async Task CheckBlockly()
    {

    }

    public Toolbox toolbox = new Toolbox{
        contents = new List<Category>() {
            new Category {
                name = "Sections",
                categorystyle = "sectionCategory",
                contents = new List<Block>() {
                    new Block { type = "textHead" },
                    new Block { type = "global" }
                }
            },
            new Category {
                name = "Branch",
                categorystyle = "branchCategory",
                contents = new List<Block>() {
                    new Block { type = "label" },
                    new Block { type = "jumpRegister" },
                    new Block { type = "jump" }
                }
            },
            new Category {
                name = "Memory",
                categorystyle = "memoryCategory",
                contents = new List<Block>() {
                    new Block { type = "loadWord" },
                    new Block { type = "storeWord" }
                }
            },
            new Category {
                name = "Arithmetic",
                categorystyle = "arithmeticCategory",
                contents = new List<Block>() {
                    new Block { type = "arithmeticImmediate" },
                    new Block { type = "loadHighImmediate" }
                }
            }
        }
    };
}